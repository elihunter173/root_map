<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Root Clearing Names</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
        }

        .image-container {
            position: relative;
            display: inline-block;
        }

        .main-image {
            display: block;
            max-width: 100vw;
            max-height: 100vh;
            width: auto;
            height: auto;
        }

        .text-overlay {
            position: absolute;
            color: white;
            font-size: var(--responsive-font-size);
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            transform: translate(-50%, -50%);
            text-align: center;
            white-space: nowrap;
            cursor: move;
            user-select: none;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        .text-overlay:hover {
            background-color: rgba(0, 0, 0, 0.3);
        }

        .text-overlay.dragging {
            background-color: rgba(0, 0, 0, 0.5);
        }

        .text-overlay.editing {
            background-color: rgba(255, 255, 255, 0.9);
            color: black;
            outline: 2px solid #007bff;
        }

        .text-input {
            background: transparent;
            border: none;
            color: inherit;
            font: inherit;
            text-align: center;
            outline: none;
            width: 100%;
            min-width: 50px;
        }

        .button-container {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 1000;
        }

        .button {
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            margin: 0;
        }

        .upload-button {
            background-color: #ffc107;
            color: black;
        }

        .upload-button:hover {
            background-color: #e0a800;
        }

        .json-button {
            background-color: #28a745;
            color: white;
        }

        .json-button:hover {
            background-color: #1e7e34;
        }

        .download-button {
            background-color: #007bff;
            color: white;
        }

        .download-button:hover {
            background-color: #0056b3;
        }

        .file-input {
            display: none;
        }

        .image-selector {
            background-color: #6f42c1;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            margin: 0;
        }

        .image-selector:hover {
            background-color: #5a32a3;
        }

        /* Text positioning - modify left and top values to customize positions */
    </style>
</head>
<body>
    <input type="file" id="jsonFileInput" class="file-input" accept=".json" onchange="uploadJSON(event)">

    <div class="button-container">
        <button class="button upload-button" onclick="document.getElementById('jsonFileInput').click()">Upload JSON</button>
        <button class="button json-button" onclick="downloadJSON()">Download JSON</button>
        <button class="button download-button" onclick="downloadImage()">Download Image</button>
        <select class="image-selector" onchange="changeImage(this.value)">
            <option value="autumn.webp">Autumn</option>
            <option value="lake.webp">Lake</option>
            <option value="winter.webp">Winter</option>
        </select>
    </div>

    <div class="image-container">
        <img src="autumn.webp" alt="Autumn scene" class="main-image">

        <!-- Text overlays will be dynamically generated -->
    </div>

    <script>
        let textOverlays = [];
        let draggedElement = null;
        let startX, startY, startLeft, startTop;

        // Update responsive font size based on image height
        function updateFontSize() {
            const image = document.querySelector('.main-image');
            if (image && image.offsetHeight > 0) {
                // Set font size to 3% of image height
                const fontSize = Math.max(12, image.offsetHeight * 0.03);
                document.documentElement.style.setProperty('--responsive-font-size', fontSize + 'px');
            }
        }

        // Create text overlays dynamically
        function createTextOverlays() {
            const container = document.querySelector('.image-container');

            textOverlays.forEach((overlay, index) => {
                const div = document.createElement('div');
                div.className = `text-overlay text-${index + 1}`;
                div.textContent = overlay.text;
                div.style.left = overlay.left + '%';
                div.style.top = overlay.top + '%';
                container.appendChild(div);
            });

            // Add event listeners to all text overlays
            document.querySelectorAll('.text-overlay').forEach(element => {
                element.addEventListener('mousedown', startDrag);
                element.addEventListener('dblclick', startEdit);
            });

            // Update font size after creating overlays
            updateFontSize();
        }


        function startDrag(e) {
            // Don't start drag if we're editing
            if (e.target.classList.contains('editing') || e.target.tagName === 'INPUT') {
                return;
            }

            draggedElement = e.target;
            draggedElement.classList.add('dragging');

            const rect = draggedElement.getBoundingClientRect();
            const containerRect = document.querySelector('.image-container').getBoundingClientRect();

            startX = e.clientX;
            startY = e.clientY;
            startLeft = rect.left + rect.width/2 - containerRect.left;
            startTop = rect.top + rect.height/2 - containerRect.top;

            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', stopDrag);

            e.preventDefault();
        }

        function drag(e) {
            if (!draggedElement) return;

            const container = document.querySelector('.image-container');
            const image = document.querySelector('.main-image');
            const containerRect = container.getBoundingClientRect();

            const deltaX = e.clientX - startX;
            const deltaY = e.clientY - startY;

            const newLeft = startLeft + deltaX;
            const newTop = startTop + deltaY;

            // Convert to percentages relative to image
            const leftPercent = (newLeft / image.offsetWidth) * 100;
            const topPercent = (newTop / image.offsetHeight) * 100;

            // Constrain to image bounds
            const clampedLeft = Math.max(0, Math.min(100, leftPercent));
            const clampedTop = Math.max(0, Math.min(100, topPercent));

            draggedElement.style.left = clampedLeft + '%';
            draggedElement.style.top = clampedTop + '%';
        }

        function stopDrag() {
            if (draggedElement) {
                draggedElement.classList.remove('dragging');
                draggedElement = null;
            }
            document.removeEventListener('mousemove', drag);
            document.removeEventListener('mouseup', stopDrag);
        }

        // Function to get all text positions
        function getTextPositions() {
            const positions = [];
            document.querySelectorAll('.text-overlay').forEach((element) => {
                const text = element.textContent;
                const left = parseFloat(element.style.left) || parseFloat(getComputedStyle(element).left) / element.offsetParent.offsetWidth * 100;
                const top = parseFloat(element.style.top) || parseFloat(getComputedStyle(element).top) / element.offsetParent.offsetHeight * 100;

                positions.push({
                    text: text,
                    left: Math.round(left * 10000) / 10000,
                    top: Math.round(top * 10000) / 10000
                });
            });
            return positions;
        }

        // Edit functionality
        function startEdit(e) {
            const element = e.target;

            // Prevent dragging while editing
            if (element.classList.contains('editing')) {
                return;
            }

            element.classList.add('editing');

            const currentText = element.textContent;
            element.innerHTML = `<input type="text" class="text-input" value="${currentText}">`;

            const input = element.querySelector('.text-input');
            input.focus();
            input.select();

            // Save on Enter or blur
            function finishEdit() {
                const newText = input.value || currentText;
                element.textContent = newText;
                element.classList.remove('editing');
                input.removeEventListener('blur', finishEdit);
                input.removeEventListener('keydown', handleKeydown);
            }

            function handleKeydown(e) {
                if (e.key === 'Enter') {
                    finishEdit();
                } else if (e.key === 'Escape') {
                    element.textContent = currentText;
                    element.classList.remove('editing');
                    input.removeEventListener('blur', finishEdit);
                    input.removeEventListener('keydown', handleKeydown);
                }
            }

            input.addEventListener('blur', finishEdit);
            input.addEventListener('keydown', handleKeydown);

            e.stopPropagation();
        }

        // Upload JSON file
        function uploadJSON(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const uploadedPositions = JSON.parse(e.target.result);

                    // Validate the JSON structure
                    if (!Array.isArray(uploadedPositions)) {
                        throw new Error('JSON must be an array of position objects');
                    }

                    // Validate each position object
                    for (const pos of uploadedPositions) {
                        if (!pos.text || typeof pos.left !== 'number' || typeof pos.top !== 'number') {
                            throw new Error('Each position must have text, left, and top properties');
                        }
                    }

                    // Clear existing text overlays
                    document.querySelectorAll('.text-overlay').forEach(el => el.remove());

                    // Update textOverlays and recreate
                    textOverlays = uploadedPositions;
                    createTextOverlays();

                    console.log('Successfully loaded JSON file with', uploadedPositions.length, 'text overlays');
                } catch (error) {
                    console.error('Error loading JSON file:', error);
                    alert('Error loading JSON file: ' + error.message);
                }
            };

            reader.readAsText(file);
            // Reset the file input so the same file can be uploaded again
            event.target.value = '';
        }

        // Download positions as JSON
        function downloadJSON() {
            const positions = getTextPositions();
            const jsonString = JSON.stringify(positions, null, 2);

            const blob = new Blob([jsonString], { type: 'application/json' });
            const link = document.createElement('a');
            link.download = 'positions.json';
            link.href = URL.createObjectURL(blob);
            link.click();
        }

        // Download image with overlays
        function downloadImage() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const img = document.querySelector('.main-image');
            const container = document.querySelector('.image-container');

            // Set canvas size to match the displayed image
            canvas.width = img.offsetWidth;
            canvas.height = img.offsetHeight;

            // Draw the base image
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            // Draw text overlays
            document.querySelectorAll('.text-overlay').forEach(overlay => {
                const text = overlay.textContent;
                const left = parseFloat(overlay.style.left) / 100 * canvas.width;
                const top = parseFloat(overlay.style.top) / 100 * canvas.height;

                // Set text style to match CSS with responsive font size
                const responsiveFontSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--responsive-font-size'));
                ctx.font = `bold ${responsiveFontSize}px Arial`;
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Add text shadow
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
                ctx.shadowBlur = 4;

                // Draw the text
                ctx.fillText(text, left, top);
            });

            // Download the canvas as an image
            const link = document.createElement('a');
            link.download = 'map.png';
            link.href = canvas.toDataURL();
            link.click();
        }

        // Load positions from JSON file
        async function loadPositions(imageName) {
            // Clear existing text overlays
            document.querySelectorAll('.text-overlay').forEach(el => el.remove());

            const positionsFile = `${imageName}_positions.json`;
            try {
                const response = await fetch(positionsFile);
                if (response.ok) {
                    textOverlays = await response.json();
                    console.log(`Loaded positions from ${positionsFile}`);
                    createTextOverlays();
                } else {
                    throw new Error(`${positionsFile} not found`);
                }
            } catch (error) {
                console.error(`Could not load ${positionsFile}:`, error);
                console.log(`No text overlays will be displayed. Please ensure ${positionsFile} exists.`);
                textOverlays = [];
            }
        }

        // Initialize the page
        function initializePage() {
            // Check for map query parameter
            const urlParams = new URLSearchParams(window.location.search);
            const mapParam = urlParams.get('map');

            let initialMap = 'autumn';
            if (mapParam) {
                const mapImg = mapParam + '.webp';
                // Validate that the map exists in our options
                const selector = document.querySelector('.image-selector');
                const validMaps = Array.from(selector.options).map(opt => opt.value);

                if (validMaps.includes(mapImg)) {
                    initialMap = mapParam;
                    // Update the selector to match
                    selector.value = mapImg;
                    // Update the image src
                    document.querySelector('.main-image').src = mapImg;
                }
            }

            loadPositions(initialMap);
        }

        initializePage();

        // Update font size on window resize
        window.addEventListener('resize', updateFontSize);

        // Update font size when image loads
        document.querySelector('.main-image').addEventListener('load', updateFontSize);

        // Change image function
        function changeImage(imagePath) {
            const img = document.querySelector('.main-image');
            img.src = imagePath;

            // Update alt text based on selection
            const imageName = imagePath.replace('.webp', '');
            img.alt = imageName.charAt(0).toUpperCase() + imageName.slice(1) + ' scene';

            // Load positions for the selected image
            loadPositions(imageName);

            // Update font size after image loads
            img.onload = updateFontSize;

            // Update URL query params
            const url = new URL(window.location);
            url.searchParams.set('map', imageName);
            window.history.pushState({}, '', url);
        }

        // Make function globally available
        window.getTextPositions = getTextPositions;

        console.log('Drag text boxes to move them. Double-click to edit text. Call getTextPositions() in console to see current positions.');
    </script>
</body>
</html>
